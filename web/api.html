<!--
 KnowWhere API Documentation
 Static docs served by the web container at /web
-->
<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
  <meta charset="utf-8">
  <title>KnowWhere API Documentation</title>
  <meta name="description" content="KnowWhere semantic search API reference">
  <meta name="author" content="KnowWhere">
  <meta http-equiv="cleartype" content="on">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link rel="stylesheet" href="css/hightlightjs-dark.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/highlight.min.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,300;0,400;0,500;1,300&family=Source+Code+Pro:wght@300&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="css/style.css" media="all">
  <script>hljs.initHighlightingOnLoad();</script>
</head>

<body>
<script>
  // Load sidebar and GitHub corner components from `components/` and insert into the page.
  document.addEventListener('DOMContentLoaded', async function () {
    try {
      const [sidebarRes, cornerRes, faviconRes] = await Promise.all([
        fetch('components/sidebar.html'),
        fetch('components/github-corner.html'),
        fetch('components/favicon.html')
      ]);

      if (sidebarRes && sidebarRes.ok) {
        const sidebarText = await sidebarRes.text();
        const wrapper = document.createElement('div');
        wrapper.innerHTML = sidebarText;
        const node = wrapper.firstElementChild;
        if (node) {
          document.body.insertBefore(node, document.body.firstChild);
          // Set hrefs for scroll links to be intra-page anchors on api.html
          const items = node.querySelectorAll('.scroll-to-link');
          items.forEach(li => {
            const target = li.getAttribute('data-target');
            const a = li.querySelector('a');
            if (!a || !target) return;
            a.setAttribute('href', '#' + target);
          });
        }
      }

      if (cornerRes && cornerRes.ok) {
        const cornerText = await cornerRes.text();
        const wrapper2 = document.createElement('div');
        wrapper2.innerHTML = cornerText;
        const node2 = wrapper2.firstElementChild;
        if (node2) document.body.appendChild(node2);
      }

      if (faviconRes && faviconRes.ok) {
        const favText = await faviconRes.text();
        const headWrapper = document.createElement('div');
        headWrapper.innerHTML = favText;
        // Insert each child into head
        Array.from(headWrapper.children).forEach(ch => document.head.appendChild(ch));
      }

      // Notify any scripts that components were loaded
      document.dispatchEvent(new Event('componentsLoaded'));
    } catch (e) {
      console.error('Failed to load components:', e);
    }
  });
</script>
<div class="content-page">
  <div class="content-code"></div>
  <div class="content">
    <div class="overflow-hidden content-section" id="content-get-started">
      <h1>Get started</h1>
      <p>
        KnowWhere is a Fastify + TypeScript API that exposes hybrid (lexical + semantic) search for academic papers
        stored in PostgreSQL with <code>pgvector</code> and <code>tsvector</code>. It ships with two model sidecars: an embedding service and an optional reranker.
      </p>
      <p>Local quickstart (all containers):</p>
      <ol>
        <li>Copy <code>.env.example</code> to <code>.env</code> and set database + API key values.</li>
        <li>Build & start: <code>docker compose build</code> then <code>docker compose up -d</code>.</li>
        <li>Docs site (Vercel): <code>https://&lt;your-vercel-domain&gt;/web</code>. API: <code>http://localhost:3000</code>.</li>
      </ol>
      <p>For production, deploy the four containers (<code>api</code>, <code>embedding</code>, <code>reranker</code>, <code>db</code>) against your own Postgres/pgvector. Set <code>DATABASE_URL</code>, <code>EMBEDDING_ENDPOINT</code>, and <code>RERANK_ENDPOINT</code>.</p>

      <div class="card-bg p-6 rounded-2xl mt-6 text-center" style="background: rgba(133,0,222,0.05); border: 1px solid rgba(133,0,222,0.15);">
        <h3 class="mb-3">Provision an API key (Google login + licensing)</h3>
        <p class="text-muted">Sign in with Google, then generate a licensed API key stored in MongoDB (see <code>docs/installer-roadmap.md</code>).</p>
        <div class="key-box flex flex-col items-center text-center gap-3 mt-4">
          <div id="key-auth-state" class="w-full flex justify-center">
            <button id="key-login-btn" class="btn btn-primary">
              Login with
              <img src="/images/google-wordmark-white.png" alt="Google" style="height:18px; width:auto; margin-right:8px; vertical-align:middle;">
            </button>
          </div>
          <div id="key-gen-panel" class="hidden w-full flex flex-col gap-2 items-center">
            <div class="key-actions">
              <div class="key-input-wrapper">
                <input id="generated-key" type="text" class="search-input key-input" placeholder="Your API key will appear here" readonly>
                <button type="button" id="copy-key" class="btn btn-primary key-copy">Copy</button>
              </div>
              <button id="generate-key" class="btn btn-primary key-generate">Generate API key</button>
            </div>
            <p class="text-muted mt-1 text-center w-full" id="key-status"></p>
          </div>
        </div>
      </div>

      <div class="card-bg p-6 rounded-2xl mt-6" style="background: rgba(255,255,255,0.04); border: 1px solid rgba(255,255,255,0.1);">
        <h3 class="mb-3 text-center">Store deployment config (.env) in Mongo (encrypted)</h3>
        <p class="text-muted text-center">Saved config is encrypted with <code>CONFIG_ENC_KEY</code> and fetched by the installer to write container env files.</p>
        <div class="flex flex-col gap-3 mt-3">
          <textarea id="config-text" class="search-input" rows="8" placeholder="Paste your .env contents here"></textarea>
          <div class="flex gap-2 justify-center">
            <button id="config-save" class="btn btn-primary">Save config</button>
            <button id="config-reload" class="btn btn-secondary">Reload saved</button>
          </div>
          <p class="text-muted" id="config-status"></p>
        </div>
      </div>
    </div>

        <div class="overflow-hidden content-section" id="content-auth">
      <h2>Authentication & rate limits</h2>
      <p>The API supports a static key. If <code>API_KEY</code> is set in the environment, every request (except health) must include <code>x-api-key: &lt;API_KEY&gt;</code>. If <code>API_KEY</code> is unset, endpoints are open.</p>
      <h4>Headers</h4>
      <table class="central-overflow-x">
        <thead>
        <tr><th>Header</th><th>Example</th><th>Description</th></tr>
        </thead>
        <tbody>
        <tr><td>x-api-key</td><td><code>your-api-key</code></td><td>Required when <code>API_KEY</code> is configured.</td></tr>
        <tr><td>Content-Type</td><td><code>application/json</code></td><td>Required on POST endpoints.</td></tr>
        </tbody>
      </table>
      <h4>Rate limits</h4>
      <table>
        <thead>
        <tr><th>Endpoint</th><th>Limit</th><th>Behavior on exceed</th></tr>
        </thead>
        <tbody>
        <tr><td>POST /search</td><td>30 requests / minute / key (route-level)</td><td><code>429 TOO_MANY_REQUESTS</code></td></tr>
        <tr><td>Global</td><td>Configurable via <code>RATE_LIMIT_MAX</code> / <code>RATE_LIMIT_WINDOW</code> (defaults 100 req / 60s)</td><td><code>429 TOO_MANY_REQUESTS</code></td></tr>
        </tbody>
      </table>
    </div>

    <div class="overflow-hidden content-section" id="content-ingest">
      <h2>POST /ingest</h2>
      <p>Kick off ingestion without leaving the API. This endpoint dispatches a background job to fetch and store sources, then backfill embeddings as part of the ingest script.</p>
      <div class="code-tabs" data-tabs="ingest-request">
        <div class="tab-buttons">
          <button class="tab-button active" data-tab="curl">cURL</button>
          <button class="tab-button" data-tab="node">Node.js</button>
          <button class="tab-button" data-tab="python">Python</button>
        </div>
        <div class="tab-panel active" data-tab-panel="curl">
<pre><code class="bash">curl -X POST http://localhost:3000/ingest \
  -H "Content-Type: application/json" \
  -H "x-api-key: &lt;API_KEY&gt;" \
  -d '{
    "source": "arxiv",
    "query": "cat:cs.CL",
    "count": 25
}'</code></pre>
        </div>
        <div class="tab-panel" data-tab-panel="node">
<pre><code class="javascript">await fetch("http://localhost:3000/ingest", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
    "x-api-key": "&lt;API_KEY&gt;"
  },
  body: JSON.stringify({
    source: "crossref",
    query: "graph neural networks",
    count: 20
  })
});</code></pre>
        </div>
        <div class="tab-panel" data-tab-panel="python">
<pre><code class="python">import requests

requests.post(
    "http://localhost:3000/ingest",
    headers={"Content-Type": "application/json", "x-api-key": "&lt;API_KEY&gt;"},
    json={"source": "openalex", "query": "foundation models", "count": 15},
    timeout=30,
)</code></pre>
        </div>
      </div>
      <h4>Body parameters</h4>
      <table class="central-overflow-x">
        <thead>
        <tr><th>Field</th><th>Type</th><th>Description</th></tr>
        </thead>
        <tbody>
        <tr><td>source</td><td>"arxiv" | "crossref" | "openalex"</td><td>Which ingest pipeline to run.</td></tr>
        <tr><td>query</td><td>string</td><td>Search query (e.g., arXiv category or keyword).</td></tr>
        <tr><td>count</td><td>int (max 500)</td><td>Max records to pull (defaults to 50).</td></tr>
        </tbody>
      </table>
      <p>Response: <code>202 Accepted</code> with a job PID. Job logs stream to the API container.</p>
    </div>

    <div class="overflow-hidden content-section" id="content-search">
      <h2>POST /search</h2>
      <p>Performs hybrid retrieval over academic papers (or chunks). Returns ranked items for RAG; the API does not generate prose answers.</p>
      <div class="code-tabs" data-tabs="search-request">
        <div class="tab-buttons">
          <button class="tab-button active" data-tab="curl">cURL</button>
          <button class="tab-button" data-tab="node">Node.js</button>
          <button class="tab-button" data-tab="python">Python</button>
        </div>
        <div class="tab-panel active" data-tab-panel="curl">
<pre><code class="bash">curl -X POST http://localhost:3000/search \
  -H "x-api-key: &lt;API_KEY&gt;" \
  -H "Content-Type: application/json" \
  -d '{
    "q": "graph neural networks for molecules",
    "mode": "hybrid",
    "level": "paper",
    "limit": 10,
    "filters": {"yearFrom": 2020, "source": "arxiv"}
}'</code></pre>
        </div>
        <div class="tab-panel" data-tab-panel="node">
<pre><code class="javascript">const response = await fetch("http://localhost:3000/search", {
  method: "POST",
  headers: {
    "x-api-key": "&lt;API_KEY&gt;",
    "Content-Type": "application/json"
  },
  body: JSON.stringify({
    q: "graph neural networks for molecules",
    mode: "hybrid",
    level: "chunk",
    limit: 8,
    filters: { subject: "cs.LG" }
  })
});

const data = await response.json();
console.log(data);</code></pre>
        </div>
        <div class="tab-panel" data-tab-panel="python">
<pre><code class="python">import requests

response = requests.post(
    "http://localhost:3000/search",
    headers={
        "x-api-key": "&lt;API_KEY&gt;",
        "Content-Type": "application/json",
    },
    json={
        "q": "graph neural networks for molecules",
        "mode": "semantic",
        "level": "paper",
        "limit": 5,
        "filters": {"venue": "ICLR"},
    },
    timeout=15,
)

print(response.json())</code></pre>
        </div>
      </div>
<pre class="response-block"><code class="json">{
  "results": [
    {
      "id": "arxiv:2401.12345",
      "title": "Graph Neural Networks for Molecules",
      "abstract": "We explore ...",
      "doi": "10.1234/example",
      "url": "https://arxiv.org/abs/2401.12345",
      "subjects": ["cs.LG"],
      "source": "arxiv",
      "snippet": "Graph neural networks (GNNs) have emerged ...",
      "lexScore": 0.52,
      "semScore": 0.88,
      "hybridScore": 0.73,
      "chunkId": 12
    }
  ],
  "mode": "hybrid",
  "level": "chunk"
}</code></pre>
      <h4>Body parameters</h4>
      <table class="central-overflow-x">
        <thead>
        <tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr>
        </thead>
        <tbody>
        <tr><td>q</td><td>string</td><td>Yes</td><td>User query text.</td></tr>
        <tr><td>mode</td><td>"hybrid" | "lexical" | "semantic"</td><td>No (default hybrid)</td><td>Hybrid fuses lexical + semantic; lexical uses only <code>tsvector</code>; semantic uses only embeddings.</td></tr>
        <tr><td>level</td><td>"paper" | "chunk"</td><td>No (default paper)</td><td>Return full papers or chunk-level hits.</td></tr>
        <tr><td>limit</td><td>integer</td><td>No (default 10, max 50)</td><td>Maximum results to return.</td></tr>
        <tr><td>filters.yearFrom / yearTo</td><td>integer</td><td>No</td><td>Inclusive publication year range.</td></tr>
        <tr><td>filters.venue</td><td>string</td><td>No</td><td>Filter by venue name.</td></tr>
        <tr><td>filters.subject</td><td>string</td><td>No</td><td>Filter by subject/category (e.g., <code>cs.LG</code>).</td></tr>
        <tr><td>filters.source</td><td>string</td><td>No</td><td>Filter by source label (e.g., arxiv, crossref).</td></tr>
        </tbody>
      </table>
    </div>

    <div class="overflow-hidden content-section" id="content-embed">
      <h2>POST /embed</h2>
      <p>Get embeddings directly from the API (delegates to the embedding sidecar). Useful for offline prep or debugging.</p>
<pre><code class="bash">curl -X POST http://localhost:3000/embed \
  -H "Content-Type: application/json" \
  -H "x-api-key: &lt;API_KEY&gt;" \
  -d '{ "texts": ["graph neural networks", "transformer positional encodings"] }'</code></pre>
<pre class="response-block"><code class="json">{
  "embeddings": [
    [0.01, -0.02, ...],
    [0.02, -0.01, ...]
  ]
}</code></pre>
      <p>Body: <code>texts</code> (array of strings, min 1). Returns one vector per input.</p>
    </div>

    <div class="overflow-hidden content-section" id="content-rerank">
      <h2>POST /rerank</h2>
      <p>Score a small list of documents against a query using the reranker sidecar. This is the same model the search pipeline uses internally.</p>
<pre><code class="bash">curl -X POST http://localhost:3000/rerank \
  -H "Content-Type: application/json" \
  -H "x-api-key: &lt;API_KEY&gt;" \
  -d '{
    "query": "graph neural networks survey",
    "documents": [
      "Graph neural networks have emerged...",
      "Transformers are graph neural networks"
    ]
  }'</code></pre>
<pre class="response-block"><code class="json">{
  "scores": [0.82, 0.45]
}</code></pre>
      <p>Body: <code>query</code> (string) and <code>documents</code> (array of strings). Returns a score per document.</p>
    </div>

    <div class="overflow-hidden content-section" id="content-evaluate">
      <h2>POST /evaluate</h2>
      <p>Run controlled retrieval experiments against a labeled query set. The API executes searches per mode, computes IR metrics, persists results, and returns a summary.</p>
<pre><code class="bash">curl -X POST http://localhost:3000/evaluate \
  -H "Content-Type: application/json" \
  -H "x-api-key: &lt;API_KEY&gt;" \
  -d '{
    "label": "baseline-vs-hybrid",
    "k": 10,
    "modes": ["lexical","semantic","hybrid"],
    "queries": [
      {
        "id": "q1",
        "q": "self supervised speech recognition",
        "relevantIds": ["arxiv:2401.12345","arxiv:2310.11111"],
        "filters": {"subject": "cs.CL"}
      }
    ]
  }'</code></pre>
<pre class="response-block"><code class="json">{
  "runId": 12,
  "metrics": {
    "hybrid": { "precision": 0.6, "recall": 0.6, "mrr": 1.0, "latencyMs": 120, "queries": 1 },
    "lexical": { "precision": 0.3, "recall": 0.3, "mrr": 0.5, "latencyMs": 40, "queries": 1 },
    "semantic": { "precision": 0.4, "recall": 0.4, "mrr": 0.33, "latencyMs": 90, "queries": 1 }
  },
  "sample": [
    {
      "runId": 12,
      "mode": "hybrid",
      "query": "self supervised speech recognition",
      "relevantIds": ["arxiv:2401.12345","arxiv:2310.11111"],
      "retrievedIds": ["arxiv:2401.12345","arxiv:2309.22222"],
      "metrics": { "precision": 0.6, "recall": 0.6, "mrr": 1.0 },
      "latencyMs": 120
    }
  ]
}</code></pre>
      <p>Body fields: <code>label</code> (optional), <code>k</code> (default 10), <code>modes</code> (default all), <code>level</code> ("paper" | "chunk"), and <code>queries</code> array with <code>q</code>, <code>relevantIds</code>, optional <code>filters</code>.</p>
    </div>

    <div class="overflow-hidden content-section" id="content-health">
      <h2>GET /health</h2>
      <p>Lightweight readiness probe used by Docker health checks. No authentication required. You can optionally request specific services via <code>?services=db,embedding,reranker,web</code>.</p>
      <div class="code-tabs" data-tabs="health-request">
        <div class="tab-buttons">
          <button class="tab-button active" data-tab="curl">cURL</button>
          <button class="tab-button" data-tab="node">Node.js</button>
          <button class="tab-button" data-tab="python">Python</button>
        </div>
        <div class="tab-panel active" data-tab-panel="curl">
<pre><code class="bash">curl http://localhost:3000/health</code></pre>
        </div>
        <div class="tab-panel" data-tab-panel="node">
<pre><code class="javascript">const response = await fetch("http://localhost:3000/health?services=db,embedding,reranker");
console.log(await response.json());</code></pre>
        </div>
        <div class="tab-panel" data-tab-panel="python">
<pre><code class="python">import requests

response = requests.get("http://localhost:3000/health?services=db,embedding,reranker", timeout=5)
print(response.json())</code></pre>
        </div>
      </div>
<pre class="response-block"><code class="json">{
  "status": "ok",
  "services": {
    "api": "ok",
    "db": "ok",
    "embedding": "ok",
    "reranker": "ok",
    "web": "unknown"
  }
}</code></pre>
      <p>A <code>/ready</code> endpoint is also available for readiness checks (API-only).</p>
    </div>

    <div class="overflow-hidden content-section" id="content-stats">
      <h2>GET /stats</h2>
      <p>Returns aggregate counts so you can confirm ingestion coverage.</p>
<pre class="response-block"><code class="json">{
  "papers": 12850,
  "chunks": 74532,
  "subjects": 412,
  "sources": {
    "arxiv": 8200,
    "crossref": 3000,
    "openalex": 1650
  }
}</code></pre>
    </div>

    <div class="overflow-hidden content-section" id="content-logs">
      <h2>GET /logs</h2>
      <p>Fetch recent search logs (sanitized) for debugging or analytics.</p>
<pre><code class="bash">curl "http://localhost:3000/logs?limit=50" \
  -H "x-api-key: &lt;API_KEY&gt;"</code></pre>
<pre class="response-block"><code class="json">[
  {
    "id": 123,
    "query": "self supervised speech",
    "mode": "hybrid",
    "level": "paper",
    "created_at": "2025-11-22T03:11:00.000Z"
  }
]</code></pre>
      <p>Query params: <code>limit</code> (default 50, max 200).</p>
    </div>

    <div class="overflow-hidden content-section" id="content-embedding">
      <h2>Model services</h2>
      <p>The API proxies two internal HTTP sidecars and exposes equivalent POST endpoints:</p>
      <ul>
        <li><strong>Embedding</strong>: <code>POST /embed</code> (proxies <code>http://embedding:8081/embed</code>) with <code>{ texts: [string] }</code> → returns <code>embeddings: number[][]</code>.</li>
        <li><strong>Reranker</strong>: <code>POST /rerank</code> (proxies <code>http://reranker:8082/rerank</code>) with <code>{ query, documents: [string] }</code> → returns <code>scores: number[]</code>.</li>
      </ul>
      <p>Models are open-source (<code>BAAI/bge-small-en-v1.5</code> and <code>cross-encoder/ms-marco-MiniLM-L-4-v2</code>) and run CPU-only by default. Override <code>TORCH_DEVICE=gpu</code> at build time to pull CUDA wheels on NVIDIA hosts.</p>
    </div>

    <div class="overflow-hidden content-section" id="content-errors">
      <h2>Error codes</h2>
      <p>Common responses:</p>
      <table class="central-overflow-x">
        <thead>
        <tr><th>Status</th><th>Body</th><th>Meaning</th></tr>
        </thead>
        <tbody>
        <tr><td>400</td><td><code>{ "error": {...zodErrors} }</code></td><td>Malformed JSON or validation failure.</td></tr>
        <tr><td>401</td><td><code>{ "error": "unauthorized" }</code></td><td>Missing/invalid API key.</td></tr>
        <tr><td>429</td><td><code>{ "error": "Rate limit exceeded" }</code></td><td>Rate limit exceeded.</td></tr>
        <tr><td>500</td><td><code>{ "error": "Unexpected error" }</code></td><td>Unexpected server failure.</td></tr>
        <tr><td>502</td><td><code>{ "error": "Embedding request failed" }</code></td><td>Embedding/rerank sidecar error or unavailable.</td></tr>
        </tbody>
      </table>
    </div>
  </div>
  <div class="content-code"></div>
</div>

<a href="https://github.com/ticlekiwi/API-Documentation-HTML-Template" class="github-corner" aria-label="View source on Github" title="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="z-index:99999; fill:#70B7FD; color:#fff; position: fixed; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>
<script src="js/script.js"></script>
<script>
  const startLogin = (next = "/api.html") => {
    window.location.href = `/api/auth/start?next=${encodeURIComponent(next)}`;
  };

  async function fetchSession() {
    try {
      const res = await fetch("/api/auth/me");
      if (!res.ok) return { loggedIn: false };
      return res.json();
    } catch {
      return { loggedIn: false };
    }
  }

  async function initAuthUI() {
    const session = await fetchSession();
    const authState = document.getElementById("key-auth-state");
    const panel = document.getElementById("key-gen-panel");
    const loginBtn = document.getElementById("key-login-btn");
    const genBtn = document.getElementById("generate-key");
    const keyInput = document.getElementById("generated-key");
    const status = document.getElementById("key-status");
    const sidebarLogin = document.getElementById("sidebar-login");
    const sidebarLogout = document.getElementById("sidebar-logout");
    const copyBtn = document.getElementById("copy-key");
    const configText = document.getElementById("config-text");
    const configStatus = document.getElementById("config-status");
    const configSave = document.getElementById("config-save");
    const configReload = document.getElementById("config-reload");

    const setLoggedOut = () => {
      if (authState) authState.classList.remove("hidden");
      if (panel) panel.classList.add("hidden");
      if (status) status.textContent = "";
      if (sidebarLogin) sidebarLogin.style.display = "block";
      if (sidebarLogout) sidebarLogout.style.display = "none";
    };

    const setLoggedIn = (email) => {
      if (authState) {
        authState.innerHTML = `<span class="text-muted">Signed in as ${email || "Google user"}</span>`;
      }
      if (panel) panel.classList.remove("hidden");
      if (sidebarLogin) sidebarLogin.style.display = "none";
      if (sidebarLogout) sidebarLogout.style.display = "block";
    };

    if (!session.loggedIn) {
      setLoggedOut();
    } else {
      setLoggedIn(session.email);
    }

    const loadLatestKey = async () => {
      if (!keyInput || !panel) return;
      try {
        const res = await fetch("/api/keys/latest");
        if (!res.ok) return;
        const data = await res.json();
        if (data.apiKey) {
          keyInput.value = data.apiKey;
          panel.classList.remove("hidden");
        }
      } catch {
        // ignore fetch errors
      }
    };

    if (loginBtn) loginBtn.addEventListener("click", () => startLogin("/api.html"));
    if (sidebarLogin) sidebarLogin.addEventListener("click", () => startLogin("/api.html"));
    if (sidebarLogout) sidebarLogout.addEventListener("click", () => { window.location.href = "/api/auth/logout"; });
    if (genBtn && keyInput) {
      genBtn.addEventListener("click", async () => {
        status.textContent = "Generating key...";
        try {
          const res = await fetch("/api/keys/generate", { method: "POST" });
          if (!res.ok) {
            status.textContent = "Failed to generate key. Please log in again.";
            if (res.status === 401) setLoggedOut();
            return;
          }
          const data = await res.json();
          keyInput.value = data.apiKey || "";
          status.textContent = data.apiKey ? "Copy this key and set it as API_KEY (or use with x-api-key)." : "";
        } catch (e) {
          status.textContent = "Unexpected error generating key.";
        }
      });
    }
    if (copyBtn && keyInput) {
      copyBtn.addEventListener("click", async () => {
        if (!keyInput.value) return;
        try {
          await navigator.clipboard.writeText(keyInput.value);
          status.textContent = "Copied to clipboard.";
        } catch {
          status.textContent = "Copy failed.";
        }
      });
    }

    const loadConfig = async () => {
      if (!configText || !configStatus) return;
      configStatus.textContent = "Loading saved config...";
      try {
        const res = await fetch("/api/config/get");
        if (!res.ok) {
          configStatus.textContent = "No saved config found.";
          return;
        }
        const data = await res.json();
        configText.value = data.config || "";
        configStatus.textContent = data.config ? "Loaded saved config." : "No saved config found.";
      } catch {
        configStatus.textContent = "Failed to load config.";
      }
    };

    const saveConfig = async () => {
      if (!configText || !configStatus) return;
      configStatus.textContent = "Saving...";
      try {
        const res = await fetch("/api/config/set", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ config: configText.value })
        });
        if (!res.ok) {
          configStatus.textContent = "Failed to save config.";
          return;
        }
        configStatus.textContent = "Config saved.";
      } catch {
        configStatus.textContent = "Failed to save config.";
      }
    };

    if (configSave) configSave.addEventListener("click", saveConfig);
    if (configReload) configReload.addEventListener("click", loadConfig);

    if (session.loggedIn) {
      loadLatestKey();
      loadConfig();
    }
  }

  document.addEventListener("DOMContentLoaded", () => {
    initAuthUI();
  });
  document.addEventListener("componentsLoaded", () => {
    initAuthUI();
  });
</script>
</body>
</html>
